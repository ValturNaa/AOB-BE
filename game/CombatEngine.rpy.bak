init:    
# zoom and alpha transforms used to wrap various tiles and sprites in the main viewport, though they can be used anywhere.
    transform hidden:
        alpha 0.0
    transform a0p5:
        alpha 0.5
    transform visible:
        alpha 1.0
        

    transform x0p2:
        zoom 0.2
    transform x0p4:
        zoom 0.4
    transform x0p6:
        zoom 0.6
    transform x0p8:
        zoom 0.8
    transform x1:
        zoom 1.0
    transform x1p2:
        zoom 1.2
    transform x1p4:
        zoom 1.4
    transform x1p6:
        zoom 1.6
    transform x1p8:
        zoom 1.8
    transform x2:
        zoom 2.0
        
    # map movement transform
    transform MovePathN:
        xpos CurrentOverlay[StartX][StartY].XPos ypos CurrentOverlay[StartX][StartY].YPos xanchor 0.0 yanchor 0.0
        linear 1 xpos CurrentOverlay[StartX-1][StartY].XPos ypos CurrentOverlay[StartX-1][StartY].YPos xanchor 0.0 yanchor 0.0
    transform MovePathE:
        xpos CurrentOverlay[StartX][StartY].XPos ypos CurrentOverlay[StartX][StartY].YPos xanchor 0.0 yanchor 0.0
        linear 1 xpos CurrentOverlay[StartX][StartY+1].XPos ypos CurrentOverlay[StartX][StartY+1].YPos xanchor 0.0 yanchor 0.0
    transform MovePathS:
        xpos CurrentOverlay[StartX][StartY].XPos ypos CurrentOverlay[StartX][StartY].YPos xanchor 0.0 yanchor 0.0
        linear 1 xpos CurrentOverlay[StartX+1][StartY].XPos ypos CurrentOverlay[StartX+1][StartY].YPos xanchor 0.0 yanchor 0.0
    transform MovePathW:
        xpos CurrentOverlay[StartX][StartY].XPos ypos CurrentOverlay[StartX][StartY].YPos xanchor 0.0 yanchor 0.0
        linear 1 xpos CurrentOverlay[StartX][StartY-1].XPos ypos CurrentOverlay[StartX][StartY-1].YPos xanchor 0.0 yanchor 0.0
        
        

    # colours defined here
    image blue = Solid("#00ccff")
    image yellow = Solid("#ffff33")
    image black = Solid("#000000")
    image white = Solid("#fff")
    image grey = Solid("#cccccc")
    image greyer = Solid("#808080")
    image green = Solid("#00b300")

    # generic buttons defined here
    image NextTurnIdle:
        "NextTurnHover"
        alpha 0.75
    image NextTurnHover:
        "images/GUI/hourglass.png"
        zoom 2.0
    image CancelMoveIdle:
        "images/GUI/X.png"
        alpha 0.5
    image CancelMoveHover:
        "images/GUI/X.png"
    image DeploymentIdle:
        "YellowTile"
        alpha 0.5
    image DeploymentHover:
        "YellowTile"
        alpha 0.8
    image MoveIdle:
        "BlueTile"
        alpha 0.5
    image MoveHover:
        "BlueTile"
        alpha 0.8
    
    # Tiles images defined here
    image Null = LiveComposite((50, 50), (0, 0), "white")
    image Clear:
        "Null"
        alpha 0.0
    image blankTile = LiveComposite((50, 50), (0, 0), "black")
    image YellowTile = LiveComposite((50, 50), (0, 0), "yellow")
    image BlueTile = LiveComposite((50, 50), (0, 0), "blue")

    image grassTile = LiveComposite((50,50), (0, 0), "green")


    # Battle sprites defined here

    image SoldierIdle:
        "images/BattleSprites/SoldierFrontStepIdle.png"
        zoom 0.5
    image SoldierHover:
        "SoldierIdle"
        alpha 0.7
    image SoldierMove:
        "SoldierIdle"
        
        
    image BruiserIdle:
        "images/BattleSprites/BanditBruiserIdle.png"
        zoom 0.5
    image BruiserHover:
        "BruiserIdle"
        alpha 0.7
    image BruiserMoveS:
        zoom 0.5
        "images/BattleSprites/BanditBruiserIdle.png"
        pause 0.5
        "images/BattleSprites/BanditBruiserFrontStep2.png"
        pause 0.5
        "images/BattleSprites/BanditBruiserIdle.png"
        pause 0.5
        "images/BattleSprites/BanditBruiserFrontStep1.png"
        pause 0.5
        repeat
    image BruiserMoveN:
        zoom 0.5
        "images/BattleSprites/BruiserBackIdle.png"
        pause 0.5
        "images/BattleSprites/BruiserBack2.png"
        pause 0.5
        "images/BattleSprites/BruiserBackIdle.png"
        pause 0.5
        "images/BattleSprites/BruiserBack1.png"
        pause 0.5
        repeat
    image BruiserMoveE:
        zoom 0.5
        "images/BattleSprites/BruiserRightIdle.png"
        pause 0.5
        "images/BattleSprites/BruiserRight2.png"
        pause 0.5
        "images/BattleSprites/BruiserRightIdle.png"
        pause 0.5
        "images/BattleSprites/BruiserRight1.png"
        pause 0.5
        repeat
    image BruiserMoveW:
        zoom 0.5
        "images/BattleSprites/BruiserLeftIdle.png"
        pause 0.5
        "images/BattleSprites/BruiserLeft2.png"
        pause 0.5
        "images/BattleSprites/BruiserLeftIdle.png"
        pause 0.5
        "images/BattleSprites/BruiserLeft1.png"
        pause 0.5
        repeat
    image BruiserMove = ConditionSwitch("CurrentFacing == 'N'", "BruiserMoveN", "CurrentFacing == 'E'", "BruiserMoveE", "CurrentFacing == 'S'", "BruiserMoveS", "CurrentFacing == 'W'", "BruiserMoveW")

  
    

init 1 python:
    
    # used to determine the level of zoom applied to the battle map and resize the viewport accordingly
    zoomlist = [[x0p2, 0.2], [x0p4, 0.4], [x0p6, 0.6], [x0p8, 0.8], [x1, 1], [x1p2, 1.2], [x1p4, 1.4], [x1p6, 1.6], [x1p8, 1.8], [x2, 2]]
    
    def FindPos(x, ZoomLevel):
        temp1 = int(50*ZoomLevel)
        temp2 = temp1*x
        return temp2
                
    
    # one instantiated for each type of tile that exists in the game.        
    class tile(object):
        def __init__(self, Name, PassN=True, PassE=True, PassS=True, PassW=True, VisibleN=True, VisibleE=True, VisibleS=True, VisibleW=True, MoveRequired=1):
            # Type of tile, string
            self.Name = Name
            # can you move north from this tile (Boolean)
            self.PassN = PassN
            # can you move east from this tile (Boolean)
            self.PassE = PassE
            # can you move south from this tile (Boolean)
            self.PassS = PassS
            # can you move west from this tile (Boolean)
            self.PassW = PassW
            # can you see north from this tile (RANGED ATTACKS) (Boolean)
            self.VisibleN = VisibleN
            # can you see east from this tile (RANGED ATTACKS) (Boolean)
            self.VisibleE = VisibleE
            # can you see south from this tile (RANGED ATTACKS) (Boolean)
            self.VisibleS = VisibleS
            # can you see west from this tile (RANGED ATTACKS) (Boolean)
            self.VisibleW = VisibleW
            # how many move points moving onto this tile will take
            self.MoveRequired = MoveRequired
    
    # One instance created for each tile on the battlefield, keeps track of who is where.
    class battletile(object):
        def __init__(self, Visibility, XPos=0, YPos=0, UnitPresent="Null", UnitIdle="None", UnitHover="None", UnitID="None"):
            self.Name = str(self)
            # name of unit present on this tile. If none defaults to Null
            self.UnitPresent = UnitPresent
            # Float between 1 and 0, relative screen position. Needs an algorithim to calculate.
            self.XPos = XPos
            # Float between 1 and 0, relative screen position. Needs an algorithim to calculate.
            self.YPos = YPos
            # Float between 1 and 0 setting images alpha
            self.Visibility = Visibility
            # used for deployment and selection imagebuttons
            self.UnitIdle = UnitIdle
            # same as above
            self.UnitHover = UnitHover
            # used to replace the unit into the player deployment list
            self.UnitID = UnitID
            # how many routes are available to this tile
            self.RouteStore = []
            
    # One instantiated for each battle. Keeps all the 2d and 3d list arrays that make up the battlefield plus information about deployment zones.
    # can handle up to 4 armies but easily accomodate more with a few added lines. I figure up to 4 armies is enough for now.
    class battlefield(object):
        def __init__(self, Field, FieldOverlay, FieldID, PlayerDeployment, PlayerArmy, Enemy1Deployment, Enemy1Army, Enemy2=False, Enemy2Deployment=[], Enemy2Army=[], Enemy3=False, Enemy3Deployment=[], Enemy3Army=[]):
            # self
            self.Self = self
            # 2d list
            self.Field = Field
            # 2d list
            self.FieldOverlay = FieldOverlay
            # integer
            self.FieldID = FieldID
            # 2d list
            self.PlayerDeployment = PlayerDeployment
            # list
            self.PlayerArmy = PlayerArmy
            # 2d list
            self.Enemy1Deployment = Enemy1Deployment
            # list
            self.Enemy1Army = Enemy1Army
            # Boolean
            self.Enemy2 = Enemy2
            # 2d list
            self.Enemy2Deployment = Enemy2Deployment
            # list
            self.Enemy2Army = Enemy2Army
            # boolean
            self.Enemy3 = Enemy2
            # 2d list
            self.Enemy3Deployment = Enemy3Deployment
            # list
            self.Enemy3Army = Enemy3Army
            
            
    # One instantiated for every individual unit involved in each battle. Keeps track of stats without messing with the classes instantiated for breeding purposes. 
    # Monster stats for each chosen to participate passed into this class, used as needed and then discareded at the end of the battle. Any stat increases or bonuses passed back to the breeding class at the end.
    class unit(object):
        def __init__(self, BattleName, OrigionalName, PowerLevel, CurrentMorale, PhysicalResist, PRB, CharmResist, CRB, BattleSkills, Traits, MovementMax, BattleSpriteIdle, BattleSpriteHover, BattleSpriteMove, ArmyID, PAB, CAB):
            # used to append self to lists
            self.Self = self
            # string used to reference self
            self.BattleName = BattleName
            # used to help transition stat changes back to origional seeding monster in the breeding engine
            self.OrigionalName = OrigionalName
            # integer, used to gaugue army power level. Some sort of sum based on four basic stats
            self.PowerLevel = PowerLevel
            # integer
            self.CurrentMorale = CurrentMorale
            # integer
            self.BufferMorale = 0
            # integer
            self.MaxMorale = CurrentMorale
            # integer, used to offset physical damage
            self.PhysicalResist = PhysicalResist
            # integer. stands for physical resist bonus, multiplier bonus applied to Physical resist
            self.PRB = PRB
            # integer. offests charm damage
            self.CharmResist = CharmResist
            # integer, stands for charm resist bonus. bonus Applied to Charm resistance 
            self.CRB = CRB
            # list.
            self.BattleSkills = BattleSkills
            # list
            self.Traits = Traits
            # integer
            self.MovementMax = MovementMax
            # integer
            self.MovementCurrent = MovementMax
            # string
            self.BattleSpriteIdle = BattleSpriteIdle
            # string
            self.BattleSpriteHover = BattleSpriteHover
            # string
            self.BattleSpriteMove = BattleSpriteMove
            # integer
            self.ArmyID = ArmyID
            # Stands for physical attack bonus, integer
            self.PAB = PAB
            # Stands for charm attack bonus, integer
            self.CAB = PAB
            
            
    # every type of attack needs an instance of this
    class weapon(object):
        def __init__(self, Name, Range, Damage, DamageType, Attacks, Cooldown, Bonuses=[]):
            # string, used to append self to lists
            self.Name = Name
            # integer, distance in tiles not including own
            self.Range = Range
            # integer, base damage before moster stats and multipliers are applied
            self.Damage = Damage
            # string, charm physical etc.
            self.DamageType = DamageType
            # integer,number of hits per attack. used to create multi hit attacks
            self.Attacks = Attacks
            # integer
            self.Cooldown = Cooldown
            # 2d list, traits species etc that this weapon has a bonus agaisnt [[trait, bonus in percent], [monster, bonus in percent]]
            self.Bonuses = Bonuses
            
    
    # various battle engine only variables here
    
    # if a battlefield is created, it muct be appended to this
    BattleFieldList = []
    # used to identify which battlefield we will be using
    CurrentBattlefieldID = 0
    # boolean to switch between deployment and battle mode
    DeploymentPhase = True
    # what the battle viewport draws on. Is changed to whatever 2d battlefield array we are using for this battle
    CurrentMap = []
    # used for movement and attack buttons, same basis as CurrentMap
    CurrentOverlay = []
    # Players deployment area, same basis as CurrentMap
    CurrentPlayerDeployment = []
    # enemy 1's deployment area, same basis as CurrentMap
    CurrentEnemy1Deployment = []
    # enemy 2's deployment area (if used), same basis as CurrentMap
    CurrentEnemy2Deployment = []
    # enemy 3's deployment area (if used), same basis as CurrentMap
    CurrentEnemy3Deployment = []
    # Used to end battle and return to farm screen
    BattleEnd = False
    # Monsters in the players army, used to feed the battlefield class
    PlayerArmy = []
    # Used to keep track of what units have been deployed and which haven't
    PlayerPartyDep = []
    # Enemy 1's army, feed to battlefield class
    Enemy1Army = []
    # same as player 1 party deployment
    Enemy1ArmyDep = []
    # Enemy 2's army, feed to battlefield class
    Enemy2Army = []
    # same as player 2 party deployment
    Enemy2ArmyDep = []
    # Enemy 3's army, feed to battlefield class
    Enemy3Army = []
    # same as player 3 party deployment
    Enemy3ArmyDep = []

    DeploymentStart = False
    ActiveDeployment = []
    CompletedDeployment = []
    PlaceUnit = False
    UnitPlaced = False
    TempIndecesX = 0
    TempIndecesY = 0
    DeploymentRandomiser = 0
    
    
    
    # define weapons here
    Stab = weapon("Stab", 1, 8, "Physical", 1, 1)
    Club = weapon("Club", 1, 5, "Physcial", 1, 1)
    
    
    
    # define units here
    Soldier = unit("PlaceHolder", "Soldier", 50, 100, 10, 0, 0, 0, [Stab], [], 4, "SoldierIdle", "SoldierHover", "SoldierMove", 1, 0, 0)
    Bruiser = unit("PlaceHolder", "Bruiser", 35, 75, 2, 0, 0, 0, [Club], [], 4, "BruiserIdle", "BruiserHover", "BruiserMove", 2, 0, 0)


    
    
    
    
label CombatEngine:
    python:
        # sets up player army. Works for a fixed army, but will need some sort of selection screen and drawing stats from breeding classes.
        p1 = unit("p1", "Bruiser", 35, 75, 2, 0, 0, 0, [Club], [], 4, "BruiserIdle", "BruiserHover", "BruiserMove", 1, 0, 0)
        p2 = unit("p2", "Bruiser", 35, 75, 2, 0, 0, 0, [Club], [], 4, "BruiserIdle", "BruiserHover", "BruiserMove", 1, 0, 0)
        p3 = unit("p3", "Bruiser", 35, 75, 2, 0, 0, 0, [Club], [], 4, "BruiserIdle", "BruiserHover", "BruiserMove", 1, 0, 0)
        PlayerArmy = [p1, p2, p3]
        PlayerPartyDep = [p1, p2, p3]
        # sets up enely 1's army. Will need a generator for random events and scripted ones some sort of selection method
        e1 = unit("e1", "Soldier", 50, 100, 10, 0, 0, 0, [Stab], [], 4, "SoldierIdle", "SoldierHover", "SoldierMove", 2, 0, 0)
        e2 = unit("e2","Soldier", 50, 100, 10, 0, 0, 0, [Stab], [], 4, "SoldierIdle", "SoldierHover", "SoldierMove", 2, 0, 0)
        e3 = unit("e3","Soldier", 50, 100, 10, 0, 0, 0, [Stab], [], 4, "SoldierIdle", "SoldierHover", "SoldierMove", 2, 0, 0)
        Enemy1Army = [e1, e2, e3]
        Enemy1ArmyDep = [e1, e2, e3]
        # completeddeployment keeps track of which units have been deployed, used for all armies in turn and reset after use
        CompletedDeployment = []
        # Instantiation of battlefield.  Will need a generator for random events and scripted ones some sort of selection method
        GrassFieldMap = battlefield(GrassField, GrassFieldOverlay, 0, GrassFieldPlayerDeploy, PlayerArmy, GrassFieldEnemy1Deploy, Enemy1Army)
        # any battlefield instance needs to be stored here
        BattleFieldList.append(TutorialBattle)
        # Set to extrapolate needed info from BattleFieldList. All that should be needed to set up "current" variables
        CurrentBattlefieldID = 0
        CurrentMap = BattleFieldList[CurrentBattlefieldID].Field
        CurrentOverlay = BattleFieldList[CurrentBattlefieldID].FieldOverlay
        CurrentPlayerDeployment = BattleFieldList[CurrentBattlefieldID].PlayerDeployment
        CurrentEnemy1Deployment = BattleFieldList[CurrentBattlefieldID].Enemy1Deployment
        # Sets the players deployment zone up on the overlay map
        for i in range(0, len(CurrentPlayerDeployment)):
            TempIndecesY = CurrentPlayerDeployment[i][0]
            TempIndecesX = CurrentPlayerDeployment[i][1]
            CurrentOverlay[TempIndecesY][TempIndecesX].UnitPresent = "Deploy"
    jump SetPos
    
label SetPos:
    python:
        for y in range(0, len(CurrentOverlay)):
            for x in range(0, len(CurrentOverlay[y])):
                CurrentOverlay[y][x].XPos = FindPos(x, zoomlist[MapZoom][1])
                CurrentOverlay[y][x].YPos = FindPos(y, zoomlist[MapZoom][1])
        DeploymentStart = True
        
    
    jump RenderMap
    
    
label RenderMap:
    if UnitPlaced == True:
        $ ActiveDeployment = []
        $ UnitPlaced = False
        $ PlaceUnit = False
    if AddZoom == 1:
        python:
            MapZoom += 1
            AddZoom = 0
            for y in range(0, len(CurrentOverlay)):
                for x in range(0, len(CurrentOverlay[y])):
                    CurrentOverlay[y][x].XPos = FindPos(x, zoomlist[MapZoom][1])
                    CurrentOverlay[y][x].YPos = FindPos(y, zoomlist[MapZoom][1])
    if MinusZoom == 1:
        python:
            MapZoom -= 1
            MinusZoom = 0
            for y in range(0, len(CurrentOverlay)):
                for x in range(0, len(CurrentOverlay[y])):
                    CurrentOverlay[y][x].XPos = FindPos(x, zoomlist[MapZoom][1])
                    CurrentOverlay[y][x].YPos = FindPos(y, zoomlist[MapZoom][1])
    if AtoB == True:
        python:
            AtoB = False
            renpy.hide_screen("CurrentMap")
            AtoB = True
            for waypoint in range(0, len(FinalPath[0].WayPoints)):
                if FinalPath[0].WayPoints[waypoint] == "N":
                    CurrentFacing = "N"
                    CurrentMove = MovePathN
                    renpy.show_screen("CurrentMap")
                    renpy.pause(1)
                    renpy.hide_screen("CurrentMap")
                    StartX -= 1
                if FinalPath[0].WayPoints[waypoint] == "E":
                    CurrentFacing = "E"
                    CurrentMove = MovePathE
                    renpy.show_screen("CurrentMap")
                    renpy.pause(1)
                    renpy.hide_screen("CurrentMap")
                    StartY += 1
                if FinalPath[0].WayPoints[waypoint] == "S":
                    CurrentFacing = "S"
                    CurrentMove = MovePathS
                    renpy.show_screen("CurrentMap")
                    renpy.pause(1)
                    renpy.hide_screen("CurrentMap")
                    StartX += 1
                if FinalPath[0].WayPoints[waypoint] == "W":
                    CurrentFacing = "W"
                    CurrentMove = MovePathW
                    renpy.show_screen("CurrentMap")
                    renpy.pause(1)
                    renpy.hide_screen("CurrentMap")
                    StartY -= 1
            AtoB = False
        call FinishMove
    show screen CurrentMap
    call screen ZoomScreen
    jump RenderMap
    
    
    
label NextTurn:
    hide screen CurrentMap
    python:
        for x in range(0, len(PlayerArmy)):
            PlayerArmy[x].MovementCurrent = PlayerArmy[x].MovementMax
    call ResetMoveVariables
    show screen CurrentMap
    jump AITurn
    
label AITurn:
    jump RenderMap

    